<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="TODO.html"><strong aria-hidden="true">1.</strong> TODOs</a></li><li class="chapter-item expanded "><a href="memo/index.html"><strong aria-hidden="true">2.</strong> 心得</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> 引文</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> 软件测试理论</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> 软件架构模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="micro-services/index.html"><strong aria-hidden="true">5.1.</strong> 微服务架构/组件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="micro-services/kubernetes/index.html"><strong aria-hidden="true">5.1.1.</strong> Kubernetes (K8s)</a></li><li class="chapter-item expanded "><a href="micro-services/service-mesh/index.html"><strong aria-hidden="true">5.1.2.</strong> 服务网格 (ServiceMesh)</a></li><li class="chapter-item expanded "><a href="micro-services/knative/index.html"><strong aria-hidden="true">5.1.3.</strong> Knative</a></li><li class="chapter-item expanded "><a href="micro-services/sealos-harden/index.html"><strong aria-hidden="true">5.1.4.</strong> Sealos 蜜罐</a></li></ol></li><li class="chapter-item expanded "><a href="cloud-native/index.html"><strong aria-hidden="true">5.2.</strong> 云原生架构</a></li><li class="chapter-item expanded "><a href="cloud-native/case/index.html"><strong aria-hidden="true">5.3.</strong> 案例</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cloud-native/case/zadig.html"><strong aria-hidden="true">5.3.1.</strong> Zadig 业务架构</a></li><li class="chapter-item expanded "><a href="cloud-native/case/code-spaces.html"><strong aria-hidden="true">5.3.2.</strong> Codespaces GitHub 在线开发环境</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="design-for-software/index.html"><strong aria-hidden="true">6.</strong> 软件设计模式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design-for-software/design-for-failure.html"><strong aria-hidden="true">6.1.</strong> 失败机制 Design for failure</a></li></ol></li><li class="chapter-item expanded "><a href="software-development-process/index.html"><strong aria-hidden="true">7.</strong> 软件工程开发流程</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> 软件发布策略</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="release-strategy/gray-release.html"><strong aria-hidden="true">8.1.</strong> 灰度发布</a></li></ol></li><li class="chapter-item expanded "><a href="refs-architecture-mode/index.html"><strong aria-hidden="true">9.</strong> 软件模式参照</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="refs-architecture-mode/api-re-design/index.html"><strong aria-hidden="true">9.1.</strong> HTTP API重新构想</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="refs-architecture-mode/api-re-design/autocode.html"><strong aria-hidden="true">9.1.1.</strong> autocode的标准API库模式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="web-site-analysis/index.html"><strong aria-hidden="true">10.</strong> 网站性能分析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="web-site-analysis/GitHub.html"><strong aria-hidden="true">10.1.</strong> GitHub</a></li><li class="chapter-item expanded "><a href="web-site-analysis/iqiyi.html"><strong aria-hidden="true">10.2.</strong> 爱奇艺</a></li></ol></li><li class="chapter-item expanded "><a href="ai/index.html"><strong aria-hidden="true">11.</strong> AI助力</a></li><li class="chapter-item expanded "><a href="best-projects/index.html"><strong aria-hidden="true">12.</strong> 优秀项目资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="best-projects/lowCode.html"><strong aria-hidden="true">12.1.</strong> 低代码/无代码</a></li></ol></li><li class="chapter-item expanded "><a href="compares/index.html"><strong aria-hidden="true">13.</strong> 常见比较</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compares/server-proxy/index.html"><strong aria-hidden="true">13.1.</strong> 服务代理软件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compares/server-proxy/nginx-vs-apache-apisx.html"><strong aria-hidden="true">13.1.1.</strong> 比较Nginx与Apache APISX</a></li></ol></li><li class="chapter-item expanded "><a href="compares/net-protocol/index.html"><strong aria-hidden="true">13.2.</strong> 网络协议</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="compares/net-protocol/grpc-vs-http.html"><strong aria-hidden="true">13.2.1.</strong> 比较gRPC服务和HTTP API</a></li></ol></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="todos"><a class="header" href="#todos">TODOs</a></h1>
<h2 id="网站性能研究"><a class="header" href="#网站性能研究">网站性能研究</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="./web-site-analysis/GitHub.html">需要继续研究分析GitHub网站的性能</a></li>
<li><input disabled="" type="checkbox"/>
<a href="./web-site-analysis/iqiyi.html">需要继续研究分析爱奇艺网站的性能</a></li>
</ul>
<h2 id="ai-助力提效"><a class="header" href="#ai-助力提效">AI 助力提效</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://medium.com/codex/top-ai-ml-libraries-for-javascript-in-2021-1aa105fa6fbe">阅读Top AI/ML Libraries for JavaScript In 2021</a></li>
<li><input disabled="" type="checkbox"/>
Playwright 结合 AI 技术，如何优化构建产物性能？</li>
<li><input disabled="" type="checkbox"/>
Playwright 结合 AI 技术，如何测试UI组件的兼容性？</li>
<li><input disabled="" type="checkbox"/>
Playwright 结合 AI 技术，如何为微服务带来实质上的提速？</li>
<li><input disabled="" type="checkbox"/>
Playwright 结合 AI 技术，如何提升网站的加载速度？
<blockquote>
<ul>
<li>参照文章: <a href="https://blog.tensorflow.org/2021/05/speed-up-your-sites-with-web-page-prefetching-using-ml.html">Speed-up your sites with web-page prefetching using Machine Learning</a></li>
<li>源码：<a href="https://github.com/tensorflow/tfx/tree/master/tfx/examples/tfjs_next_page_prediction">https://github.com/tensorflow/tfx/tree/master/tfx/examples/tfjs_next_page_prediction</a></li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="杂物"><a class="header" href="#杂物">杂物</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://www.cnblogs.com/TurboWay/p/12923814.html">Docker设置</a></li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://kubernetes.io/zh/docs/tutorials/hello-minikube/">安装 Minikube</a></li>
<li><input disabled="" type="checkbox" checked=""/>
<a href="https://kubernetes.io/zh/docs/reference/kubectl/kubectl/">kubectl 的命令控制</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="心得"><a class="header" href="#心得">心得</a></h1>
<h2 id="1-单体架构转向微服务必须更注重-模块化"><a class="header" href="#1-单体架构转向微服务必须更注重-模块化">1. 单体架构转向微服务，必须更注重 <code>模块化</code></a></h2>
<blockquote>
<p><strong>良好的架构始于模块化</strong>。拆分单体的第一步是考虑基于特性功能分割代码和数据。这个过程可以在真正在微服务环境中拆分之前在单体中完成。使代码库易于管理，通常都是一种良好的架构实践。确保每个服务都有自己的数据，并且能够控制对这些数据的访问，而且只能通过明确定义的 API 契约访问。</p>
</blockquote>
<blockquote>
<p>我看到，在很多情况下，人们会首先抽出代码逻辑，但仍然使用单体的共享数据库。这往往会导致分布式单体，这是最糟糕的单体，同时也是最糟糕的分布式。没有获得任何好处（比如，单独快速地向生产环境中部署一组特性），却还要应对微服务的复杂性。</p>
</blockquote>
<h2 id="2-单体架构转向微服务必须对-数据进行拆分"><a class="header" href="#2-单体架构转向微服务必须对-数据进行拆分">2. 单体架构转向微服务，必须对 <code>数据进行拆分</code></a></h2>
<blockquote>
<p>正确地拆分数据是从单体架构转向微服务的基础。这里将稍微详细地介绍下 GitHub 的做法。</p>
<p>首先，我们在现有的数据库模式中识别功能边界，并按照这些边界将实际的数据库表分组。例如，我们将所有存储库相关的表分到一起，所有用户相关的分到一起，所有项目相关的分到一起。我们将生成的功能分组称为<code>模式域</code>，并记录在 YAML 定义文件中。现在，这个文件就成了事实来源。在数据库模式中添加或删除表，都要更新这个文件。我们通过一种静态分析测试方法来提醒开发人员，在修改数据库模式时，要更新这个文件。</p>
<p>接下来，对于每个模式域，我们找了一个分区键。这是一个共享字段，将一个功能组中的所有信息联系在一起。例如，存储库模式域（其中包含所有与存储库相关的数据，如问题、pull 请求、评审意见）使用存储库 ID 作为分区键。最终，创建数据库模式功能组帮助我们将数据拆分到微服务架构所需的不同服务器和集群上。</p>
<p>对于当前的跨域查询，我们做了修复，以防数据拆分对产品造成破坏。在 GitHub，我们在单体中实现了一个查询监视器来帮助我们检测，并在发现跨域查询时发出告警信息。我们会根据域边界，把这些查询拆分并重写成多个，并在应用程序层实现必要的连接。在划分完功能组后，我们开始通过一个类似的过程，进一步将数据分片到相应的租户组。</p>
<p>GitHub 有超过 5000 万用户和 1 亿个存储库，在这样的规模下，功能组可能会变得非常大。这时，分区键就派上用场了。例如，一种简单的方法是根据数值范围将不同的用户分配到不同的数据存储。更常见的可能是根据每个数据集的特性（如区域和大小）所做的逻辑分组。Tenantizing 是一个很好的方法，可以将数据存储故障的爆炸半径限制在客户的一个子集里，而不是一下子影响到所有人。</p>
</blockquote>
<p><strong>心得引文</strong>：《GitHub 如何从单体架构迁移到微服务架构？》，对于Github有超过1000名的内部开发人员，内部快速增长的团队规模，让所有人都在同一个单体代码库上进行开发，不再是扩展Github最高效、最优化的方法。</p>
<h2 id="3-单体架构转向微服务-标签语义方式是多么的重要"><a class="header" href="#3-单体架构转向微服务-标签语义方式是多么的重要">3. 单体架构转向微服务， <code>标签语义方式是多么的重要</code></a></h2>
<blockquote>
<p>参照K8s的实践，通过标签来处理逻辑。而不是真正的IP地址，url地址。</p>
</blockquote>
<h2 id="4-单体架构转向微服务-从核心服务共享资源入手"><a class="header" href="#4-单体架构转向微服务-从核心服务共享资源入手">4. 单体架构转向微服务， <code>从核心服务、共享资源入手</code></a></h2>
<blockquote>
<p>我们已经花了很多时间讨论数据拆分的重要性。现在，我们换个话题，介绍下从单体中抽取服务的基础工作。一定要记住，依赖方向只能从单体内到单体外，不能反过来，否则，我们最终会得到一个分布式单体。也就是说，当从单体中抽取服务时，要从核心服务入手，然后逐步到特性层面。</p>
<p>接下来，找出开发人员在单体环境中开发时所使用的助力工具。随着时间的推移构建一些共享工具以方便单体开发，这是很常见的。例如，我们的特性标识，可以让单体开发者安心地将新特性从测试环境转到生产环境，因为在这个过程中，他们可以通过这个标识控制谁能看到这些特性。将助力工具转移出来，让开发人员在单体之外也可以使用这些工具。</p>
<p>最后，在新服务上线运行后，务必要删除旧的代码路径。通过工具来识别谁在调用这个服务，并规划好如何将流量全部导向新服务，这样你就不用老是为两套代码提供支持了。在 GitHub，我们使用一个名为 Scientist 的工具帮我们处理这种上线，我们可以用它并排运行和比较新旧代码路径。</p>
</blockquote>
<p><strong>心得引文</strong>：<a href="https://www.infoq.com/articles/github-monolith-microservices/">《GitHub 如何从单体架构迁移到微服务架构？》</a></p>
<h2 id="5-单体架构转向微服务-要解决-身份验证和授权"><a class="header" href="#5-单体架构转向微服务-要解决-身份验证和授权">5. 单体架构转向微服务， 要解决 <code>身份验证和授权</code></a></h2>
<h2 id="6-单体架构转向微服务-要解决-实现异步性和弹性代码"><a class="header" href="#6-单体架构转向微服务-要解决-实现异步性和弹性代码">6. 单体架构转向微服务， 要解决 <code>实现异步性和弹性代码</code></a></h2>
<h2 id="7-深度理解-康威定律-的核心内涵很重要"><a class="header" href="#7-深度理解-康威定律-的核心内涵很重要">7. 深度理解 <code>康威定律</code> 的核心内涵，很重要</a></h2>
<p><em><strong>Conway’s law 最初来自于Conway在1967年发表的论文</strong></em></p>
<blockquote>
<p>从康威定律的角度来看，如果一个系统的每个部分都是独立的，那么这个系统就是一个系统。</p>
</blockquote>
<blockquote>
<p>设计系统的组织其产生的设计等价于组织间的沟通结构。</p>
</blockquote>
<blockquote>
<p>如果系统架构不支持，你无法建立一个高效的组织。</p>
</blockquote>
<blockquote>
<p>第一定律：组织沟通方式会通过系统设计表达出来；</p>
<blockquote>
<p>对于复杂的，需要协作完成的系统开发，沟通是必须要持续提升的问题。每个团队由5-10人组成（沟通成本 = n(n-1)/2 - 《人月神话》），在团队内部进行频繁的、细粒度的沟通。对于团队外部，定义好接口，契约，只进行粗粒度的沟通。这样可以降低沟通成本，同时也符合高内聚，低耦合原则（代码和人员管理有些时候真是相通的）。</p>
<p>任何组织设计的系统，其结构都是对组织沟通结构的复制。反之亦然，单体架构会导致更大规模的涉众会议，更复杂的决策过程，因为交织的逻辑和共享的数据会影响所有团队。</p>
<p>例如，建立具有系统级所有权的特性团队，通过清晰定义的 API 契约确立职责边界。在遵循 API 契约的前提下，团队有充分的自由选择最适合自己的技术栈。代码库更小意味着阅读更容易、启动速度更快、问题排查更简单。开发人员不用为了提高生产力去理解一整个庞大的代码库的内部运行机制。最重要的是，服务现在可以根据各自的需求单独扩展。</p>
</blockquote>
</blockquote>
<blockquote>
<p>第二定律：时间再多一件事情也不可能做的完美，但总有时间做完一件事情</p>
<blockquote>
<p>这就是我们在用kanban管理迭代时几乎都有一列是BAU（Business As Usual ），其中会包括一些日常修复的Bug Story。敏捷开发中将迭代引入，做到持续交付，快速验证，迅速反馈，持续改进。</p>
</blockquote>
</blockquote>
<blockquote>
<p>第三定律: 线型系统和线型组织架构间有潜在的异质同态特性</p>
<blockquote>
<p>大白话就是，你想要架构成为什么样，就将团队分成怎样的结构。比如前后端分离的团队，架构就是基于前后端分离。在基于微服务设计的团队里，一个很好的理念是<strong>自管理</strong>。团队内部对于自己所负责的模块高度负责，进行端对端的开发以及运维。</p>
</blockquote>
</blockquote>
<blockquote>
<p>第四定律: 大的系统组织总是比小系统更倾向于分解</p>
<blockquote>
<p>合久必分，分久必合，团队以及架构都是在不断优化的。一个团队随着人员的增加，沟通以及管理成本一定会增加。</p>
</blockquote>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引文"><a class="header" href="#引文">引文</a></h1>
<ul>
<li><a href="https://www.infoq.cn/article/2013/10/facebook-development-deployment">Kent Beck 揭秘 Facebook 开发部署流程2013</a></li>
<li><a href="https://www.infoq.cn/article/JaCAGarck1RajiCQmbSP">揭秘 Facebook 的开发部署流程：数千名开发中没有一个测试</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件测试理论"><a class="header" href="#软件测试理论">软件测试理论</a></h1>
<p>引文参照 <a href="https://en.wikipedia.org/wiki/Software_testing">Software Testing on Wikipedia</a></p>
<h2 id="1-软件测试分类"><a class="header" href="#1-软件测试分类">1. 软件测试分类</a></h2>
<h3 id="11-testing-levels测试级别"><a class="header" href="#11-testing-levels测试级别">1.1. Testing levels(测试级别)</a></h3>
<h4 id="111-unit-testing单元测试"><a class="header" href="#111-unit-testing单元测试">1.1.1. Unit testing(单元测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Unit_testing">https://en.wikipedia.org/wiki/Unit_testing</a></p>
<blockquote>
<p>Unit testing refers to tests that verify the functionality of a specific section of code, usually at the function level. In an object-oriented environment, this is usually at the class level, and the minimal unit tests include the constructors and destructors.</p>
<p>These types of tests are usually written by developers as they work on code (white-box style), to ensure that the specific function is working as expected. One function might have multiple tests, to catch corner cases or other branches in the code. Unit testing alone cannot verify the functionality of a piece of software, but rather is used to ensure that the building blocks of the software work independently from each other.</p>
<p>Unit testing is a software development process that involves a synchronized application of a broad spectrum of defect prevention and detection strategies in order to reduce software development risks, time, and costs. It is performed by the software developer or engineer during the construction phase of the software development life cycle. Unit testing aims to eliminate construction errors before code is promoted to additional testing; this strategy is intended to increase the quality of the resulting software as well as the efficiency of the overall development process.</p>
<p>Depending on the organization's expectations for software development, unit testing might include static code analysis, data-flow analysis, metrics analysis, peer code reviews, code coverage analysis and other software testing practices.</p>
</blockquote>
<blockquote>
<p>单元测试是对软件组成单元进行测试。其目的是检验软件基本组成单位的正确性。测试的对象是软件设计的最小单位：模块，所以又称为模块测试。</p>
</blockquote>
<ul>
<li>测试阶段：编码后</li>
<li>测试对象：最小模块</li>
<li>测试人员：白盒测试工程师或开发工程师</li>
<li>测试依据：代码和注释+详细设计文档</li>
<li>测试方法：白盒测试</li>
<li>测试内容：模块接口测试、局部数据结构测试、路径测试、错误处理测试、边界测试</li>
<li>测试扩展内容：静态代码分析、数据流分析、度量分析、结对代码审查、代码覆盖度分析</li>
</ul>
<h4 id="112-integration-testing集成测试"><a class="header" href="#112-integration-testing集成测试">1.1.2. Integration testing(集成测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Integration_testing">https://en.wikipedia.org/wiki/Integration_testing</a></p>
<blockquote>
<p>集成测试也称<code>联合测试</code>、<code>组装测试</code>，将程序模块采用适当的集成策略组装起来，对系统的接口及集成后的功能进行正确性检测的测试工作。主要目的是检查软件单位之间的接口是否正确。</p>
</blockquote>
<ul>
<li>测试阶段：一般单元测试之后进行</li>
<li>测试对象：模块间的接口</li>
<li>测试人员：白盒测试工程师或开发工程师</li>
<li>测试依据：单元测试的模块+概要设计文档</li>
<li>测试方法：黑盒测试与白盒测试相结合</li>
<li>测试内容：模块之间数据传输、模块之间功能冲突、模块组装功能正确性、全局数据结构、单模块缺陷对系统的影响</li>
</ul>
<h4 id="113-system-testing系统测试"><a class="header" href="#113-system-testing系统测试">1.1.3. System testing(系统测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/System_testing">https://en.wikipedia.org/wiki/System_testing</a></p>
<blockquote>
<p>将软件系统看成是一个系统的测试。包括对功能、性能以及软件所运行的软硬件环境进行测试。时间大部分在系统测试执行阶段。</p>
</blockquote>
<ul>
<li>测试阶段：集成测试通过之后</li>
<li>测试对象：整个系统（软、硬件）</li>
<li>测试人员：黑盒测试工程师</li>
<li>测试依据：需求规格说明文档</li>
<li>测试方法：黑盒测试</li>
<li>测试内容：功能、界面、可靠性、易用性、性能、兼容性、安全性等</li>
</ul>
<h4 id="114-acceptance-testing验收测试"><a class="header" href="#114-acceptance-testing验收测试">1.1.4. Acceptance testing(验收测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Acceptance_testing">https://en.wikipedia.org/wiki/Acceptance_testing</a></p>
<blockquote>
<p>验收测试是部署软件之前的最后一个测试操作。它是技术测试的最后一个阶段，也称为<code>交付测试</code>。验收测试的目的是确保软件准备就绪，按照项目合同、任务书、双方约定的验收依据文档，向软件购买都展示该软件系统满足原始需求。</p>
</blockquote>
<ul>
<li>测试阶段：系统测试通过之后</li>
<li>测试对象：整个系统（包括软硬件）</li>
<li>测试人员：主要是最终用户或者需求方</li>
<li>测试依据：用户需求、验收标准</li>
<li>测试方法：黑盒测试</li>
<li>测试内容：同系统测试(功能...各类文档等)</li>
</ul>
<h3 id="12-testing-approach测试方法"><a class="header" href="#12-testing-approach测试方法">1.2. Testing approach(测试方法)</a></h3>
<h4 id="121-static-dynamic-and-passive-testing静态动态被动"><a class="header" href="#121-static-dynamic-and-passive-testing静态动态被动">1.2.1. Static, dynamic, and passive testing(静态、动态、被动)</a></h4>
<h4 id="122-exploratory-approach探索测试"><a class="header" href="#122-exploratory-approach探索测试">1.2.2. Exploratory approach(探索测试)</a></h4>
<h4 id="123-the-box-approach盒子测试"><a class="header" href="#123-the-box-approach盒子测试">1.2.3. The &quot;box&quot; approach(盒子测试)</a></h4>
<h5 id="1231-white-box-testing白盒子测试"><a class="header" href="#1231-white-box-testing白盒子测试">1.2.3.1. White-box testing(白盒子测试)</a></h5>
<p><a href="https://en.wikipedia.org/wiki/White-box_testing">https://en.wikipedia.org/wiki/White-box_testing</a></p>
<blockquote>
<p>白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒指的打开盒子，去研究里面的源代码和程序结果。</p>
</blockquote>
<p>一般包括：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/API_testing">API testing(接口测试)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Code_coverage">Code coverage(代码覆盖度)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fault_injection">Fault injection(故障注入)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutation_testing">Mutation testing(突变测试)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Static_testing">Static testing(静态测试)</a></li>
</ul>
<h5 id="1232-black-box-testing黑盒子测试"><a class="header" href="#1232-black-box-testing黑盒子测试">1.2.3.2. Black-box testing(黑盒子测试)</a></h5>
<p><a href="https://en.wikipedia.org/wiki/Black-box_testing">https://en.wikipedia.org/wiki/Black-box_testing</a></p>
<blockquote>
<p>黑盒测试也称功能测试，测试中把被测的软件当成一个黑盒子，不关心盒子的内部结构是什么，只关心软件的输入数据与输出数据。</p>
</blockquote>
<p>一般包括：</p>
<ul>
<li>Component interface testing(组件接口测试)</li>
<li>Visual testing(可视化测试)
<ul>
<li>Graphical user interface testing(图形化用户交互测试)</li>
</ul>
</li>
</ul>
<h5 id="1233-grey-box-testing灰盒子测试"><a class="header" href="#1233-grey-box-testing灰盒子测试">1.2.3.3. Grey-box testing(灰盒子测试)</a></h5>
<p><a href="https://en.wikipedia.org/wiki/Gray_box_testing">https://en.wikipedia.org/wiki/Gray_box_testing</a></p>
<blockquote>
<p>灰盒测试，是介于白盒测试与黑盒测试之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。</p>
</blockquote>
<h3 id="13-testing-types测试类型"><a class="header" href="#13-testing-types测试类型">1.3. Testing types(测试类型)</a></h3>
<h4 id="131-installation-testing安装测试"><a class="header" href="#131-installation-testing安装测试">1.3.1. Installation testing(安装测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Installation_testing">https://en.wikipedia.org/wiki/Installation_testing</a></p>
<h4 id="132-compatibility-testing兼容性测试"><a class="header" href="#132-compatibility-testing兼容性测试">1.3.2. Compatibility testing(兼容性测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Compatibility_testing">https://en.wikipedia.org/wiki/Compatibility_testing</a></p>
<h4 id="133-smoke-and-sanity-testing冒烟测试"><a class="header" href="#133-smoke-and-sanity-testing冒烟测试">1.3.3. Smoke and sanity testing(冒烟测试)</a></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Smoke_testing_(software)">https://en.wikipedia.org/wiki/Smoke_testing_(software)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sanity_testing">https://en.wikipedia.org/wiki/Sanity_testing</a></li>
</ul>
<blockquote>
<p>冒烟测试目的是确认软件基本功能正常，冒烟测试的执行者是版本编译人员/开发人员。</p>
</blockquote>
<blockquote>
<p>在《微软项目求生法则》一书第14章“构建过程”关于冒烟测试，就是开发人员在个人版本的软件上执行目前的冒烟测试项目，确定新的程序代码不出故障</p>
</blockquote>
<blockquote>
<p>现基本执行对象为测试人员，在正规测试一个新版本之前，投入较少的人力和时间验证基本功能，通过则测试准入。</p>
</blockquote>
<h4 id="134-regression-testing回归测试"><a class="header" href="#134-regression-testing回归测试">1.3.4. Regression testing(回归测试)</a></h4>
<blockquote>
<p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。</p>
</blockquote>
<blockquote>
<p>在整个软件测试过程中占有很大的工作量比重，软件开发的各个阶段都会进行多次回归测试。通过选择正确的回归测试策略来改进回归测试的效率和有效性是很有意义的。</p>
</blockquote>
<h4 id="135-acceptance-testing验收测试"><a class="header" href="#135-acceptance-testing验收测试">1.3.5. Acceptance testing(验收测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Acceptance_testing">https://en.wikipedia.org/wiki/Acceptance_testing</a></p>
<h4 id="136-alpha-testingα测试"><a class="header" href="#136-alpha-testingα测试">1.3.6. Alpha testing(α测试)</a></h4>
<blockquote>
<p>α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。α测试的目的是评价软件产品的FLURPS(即功能、局域化、可使用性、可靠性、性能和支持)。</p>
</blockquote>
<p>大型通用软件，在正式发布前，通常需要执行α测试和β测试。α测试不能由程序员或测试员完成。</p>
<h4 id="137-beta-testingβ测试"><a class="header" href="#137-beta-testingβ测试">1.3.7. Beta testing(β测试)</a></h4>
<blockquote>
<p>β测试是一种验收测试。β测试由软件的最终用户们在一个或多个客房场所进行。</p>
</blockquote>
<p>α测试与β测试的区别：</p>
<p>测试的场所不同：α测试是指把用户请到开发方的场所来测试,β测试是指在一个或多个用户的场所进行的测试。</p>
<p>α测试的环境是受开发方控制的,用户的数量相对比较少,时间比较集中。β测试的环境是不受开发方控制的,用户数量相对比较多,时间不集中。</p>
<p>α测试先于beta测试执行。通用的软件产品需要较大规模的β测试,测试周期比较长。</p>
<h4 id="138-functional-vs-non-functional-testing功能及非功能测试"><a class="header" href="#138-functional-vs-non-functional-testing功能及非功能测试">1.3.8. Functional vs non-functional testing(功能及非功能测试)</a></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Functional_testing">https://en.wikipedia.org/wiki/Functional_testing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-functional_testing">https://en.wikipedia.org/wiki/Non-functional_testing</a></li>
</ul>
<blockquote>
<p>功能测试是指验证代码的特定操作或功能的活动。 这些通常在代码要求文档中找到，尽管某些开发方法从用例或用户故事中工作。 功能测试倾向于回答“用户可以做到这一点”或“这个特定的功能工作。”的问题。</p>
</blockquote>
<blockquote>
<p>非功能测试是指软件的方面可能与特定函数或用户动作（例如可伸缩性或其他性能），在某些约束或安全性下的缩放性或其他性能。 测试将确定断裂点，可扩展性或性能极低的点导致不稳定执行。 非功能性要求往往是反映产品质量的那些，特别是在其用户的适用性视角的背景下。</p>
</blockquote>
<h4 id="139-api-testing接口测试"><a class="header" href="#139-api-testing接口测试">1.3.9. API testing(接口测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/API_testing">https://en.wikipedia.org/wiki/API_testing</a></p>
<h4 id="1310-continuous-testing持续测试"><a class="header" href="#1310-continuous-testing持续测试">1.3.10. Continuous testing(持续测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Continuous_testing">https://en.wikipedia.org/wiki/Continuous_testing</a></p>
<blockquote>
<p>持续测试是作为软件交付管道的一部分执行自动测试的过程，以获得关于与软件发布候选人相关的业务风险的直接反馈。持续测试测试包括验证功能要求和非功能性要求; 测试范围扩展了验证自下而上要求或用户故事，以评估与总体业务目标相关的系统要求。</p>
</blockquote>
<h4 id="1311-destructive-testing破坏性测试"><a class="header" href="#1311-destructive-testing破坏性测试">1.3.11. Destructive testing(破坏性测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Destructive_testing">https://en.wikipedia.org/wiki/Destructive_testing</a></p>
<blockquote>
<p>破坏性测试尝试导致软件或子系统失败。 即使在收到无效或意外输入的情况下，它验证软件是否正常运行，从而建立输入验证和错误管理例程的稳健性。软件故障注入，以模糊的形式是故障测试的一个例子。 各种商业非功能性测试工具与软件故障注入页面相关联; 还有许多开源和可用的免费软件工具，可提供破坏性测试。</p>
</blockquote>
<p>一般测试内容包括：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Exception_handling">Exception handling(异常处理)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Recovery_testing">Recovery testing(恢复测试)</a></li>
</ul>
<h4 id="1312-software-performance-testing软件性能测试"><a class="header" href="#1312-software-performance-testing软件性能测试">1.3.12. Software performance testing(软件性能测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Software_performance_testing">https://en.wikipedia.org/wiki/Software_performance_testing</a></p>
<blockquote>
<p>通常执行性能测试以确定系统或子系统如何在特定工作负载下的响应性和稳定性方面执行。 它还可以用于调查，测量，验证或验证系统的其他质量属性，例如可伸缩性，可靠性和资源使用情况。</p>
</blockquote>
<blockquote>
<p>负载测试主要关注测试系统可以在特定负载下继续运行，无论是大量数据还是大量用户。 这通常被称为软件可伸缩性。 当非功能性活动的相关负载测试活动通常被称为耐久性测试。 卷测试是一种测试软件功能的方法，即使某些组件（例如文件或数据库）大小而增加。 压力测试是在意外或罕见工作负载下测试可靠性的一种方式。 稳定性测试（通常称为负载或耐久性测试）检查，看看软件是否可以在可接受的时间内或高于可接受的时段中持续运行。</p>
</blockquote>
<blockquote>
<p>关于性能测试的具体目标几乎没有一致。 术语负载测试，性能测试，可扩展性测试和音量测试通常常用。</p>
</blockquote>
<blockquote>
<p>实时软件系统具有严格的计时约束。 要测试是否满足时序约束，则使用实时测试。</p>
</blockquote>
<h4 id="1313-usability-testing易用性测试"><a class="header" href="#1313-usability-testing易用性测试">1.3.13. Usability testing(易用性测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Usability_testing">https://en.wikipedia.org/wiki/Usability_testing</a></p>
<blockquote>
<p>可用性测试是检查用户界面是否易于使用和理解。 它主要涉及应用程序的使用。 这不是一种可以自动化的测试; 需要实际的用户，由熟练的UI设计人员监控。</p>
</blockquote>
<h4 id="1314-accessibility-testing可访问性测试"><a class="header" href="#1314-accessibility-testing可访问性测试">1.3.14. Accessibility testing(可访问性测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Accessibility">https://en.wikipedia.org/wiki/Accessibility</a></p>
<p>可访问性测试可能包括符合标准，例如：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Americans_with_Disabilities_Act_of_1990">Americans with Disabilities Act of 1990</a></li>
<li><a href="https://en.wikipedia.org/wiki/Section_508_Amendment_to_the_Rehabilitation_Act_of_1973">Section 508 Amendment to the Rehabilitation Act of 1973</a></li>
<li><a href="https://en.wikipedia.org/wiki/Web_Accessibility_Initiative">Web Accessibility Initiative (WAI)</a> of the <a href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium">World Wide Web Consortium (W3C)</a></li>
</ul>
<h4 id="1315-security-testing安全测试"><a class="header" href="#1315-security-testing安全测试">1.3.15. Security testing(安全测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Security_testing">https://en.wikipedia.org/wiki/Security_testing</a></p>
<blockquote>
<p>安全测试对于处理机密数据的软件至关重要，以防止黑客系统入侵。</p>
</blockquote>
<h4 id="1316-internationalization-and-localization国际化和本地化测试"><a class="header" href="#1316-internationalization-and-localization国际化和本地化测试">1.3.16. Internationalization and localization(国际化和本地化测试)</a></h4>
<blockquote>
<p>用于国际化和本地化的测试验证了该软件可以与不同的语言和地理区域一起使用。 <a href="https://en.wikipedia.org/wiki/Pseudolocalization">Pseudolocalization</a>的过程用于测试应用程序将应用程序转换为另一种语言的能力，并更容易识别当本地化过程可能将新错误引入产品。</p>
</blockquote>
<blockquote>
<p>全球化测试验证软件适用于新的文化（如不同的货币或时区）。</p>
</blockquote>
<blockquote>
<p>一般需要测试的情况：</p>
<ul>
<li>软件通常是通过转换上下文的字符串列表，而翻译器可能为模糊源字符串选择了错误的转换。</li>
<li>如果项目由几个人翻译，则在没有适当的协调的情况下或转换员不谨慎的话，技术术语可能会变得不一致。</li>
<li>文字词语翻译可能听起来不当，人为或过于技术的目标语言。</li>
<li>原始语言中的未转换消息可能在源代码中硬编码。</li>
<li>可以在运行时自动创建某些消息，并且生成的字符串可以是不正确的，功能不正确，误导或混淆。</li>
<li>软件使用源语言键盘布局没有函数的键盘快捷键，用于了在目标语言的布局中键入字符。</li>
<li>软件可能缺乏对目标语言的字符编码的支持。</li>
<li>在源语言中适用的字体和字体大小可能在目标语言中不合适; 例如，如果字体太小，CJK字符可能会变得不可读。</li>
<li>目标语言中的字符串可能比软件可以句柄长。 这可能会使字符串对用户部分不可见，或使软件崩溃或故障。</li>
<li>软件可能缺乏对读取或写作双向文本的适当支持。</li>
<li>软件可能会显示未本地化的文本的图像。</li>
<li>本地化操作系统可能具有不同命名的系统配置文件和环境变量以及日期和货币的不同格式。</li>
</ul>
</blockquote>
<h4 id="1317-development-testing开发测试"><a class="header" href="#1317-development-testing开发测试">1.3.17. Development testing(开发测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Development_testing">https://en.wikipedia.org/wiki/Development_testing</a></p>
<blockquote>
<p>开发测试是一种软件开发过程，涉及广泛的缺陷预防和检测策略的同步应用，以减少软件开发风险，时间和成本。 它由软件开发人员或工程师在软件开发生命周期的施工阶段进行。 开发测试旨在消除代码促进到其他测试之前的施工错误; 该策略旨在提高所得软件的质量以及整体开发过程的效率。</p>
</blockquote>
<blockquote>
<p>根据组织对软件开发的期望，开发测试可能包括静态代码分析，数据流分析，指标分析，对等代码评价，单元测试，代码覆盖分析，可追溯性和其他软件测试实践。</p>
</blockquote>
<h4 id="1318-ab-testingab测试"><a class="header" href="#1318-ab-testingab测试">1.3.18. A/B testing(A/B测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/A/B_testing">https://en.wikipedia.org/wiki/A/B_testing</a></p>
<blockquote>
<p>A/B测试是运行受控实验的方法，以确定提出的变化是否比当前方法更有效。 客户被路由到特征的当前版本（控制），或者收集到修改的版本（处理），并收集数据以确定哪个版本更好地实现所需结果。</p>
</blockquote>
<h4 id="1319-concurrent-testing并发测试"><a class="header" href="#1319-concurrent-testing并发测试">1.3.19. Concurrent testing(并发测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Concurrent_testing">https://en.wikipedia.org/wiki/Concurrent_testing</a></p>
<blockquote>
<p>并发测试评估使用并发计算的软件和系统的行为和性能，通常在正常使用条件下。</p>
</blockquote>
<blockquote>
<p>典型问题这种类型的测试将暴露是死锁，种族条件和共享内存/资源处理的问题。</p>
</blockquote>
<h4 id="1320-conformance-testing-or-type-testing一致性和类型测试"><a class="header" href="#1320-conformance-testing-or-type-testing一致性和类型测试">1.3.20. Conformance testing or type testing(一致性和类型测试)</a></h4>
<p><a href="https://en.wikipedia.org/wiki/Conformance_testing">https://en.wikipedia.org/wiki/Conformance_testing</a></p>
<blockquote>
<p>在软件测试中，一致性测试验证了产品根据其指定标准执行。 例如，编译器被广泛测试以确定它们是否符合该语言的公认标准。</p>
</blockquote>
<h4 id="1321-output-comparison-testing输出比较测试快照测试"><a class="header" href="#1321-output-comparison-testing输出比较测试快照测试">1.3.21. Output comparison testing(输出比较测试/快照测试)</a></h4>
<blockquote>
<p>创建显示预期输出，无论是UI的文本或屏幕截图的数据比较，有时被称为快照测试，不同于许多其他形式的测试，这不能自动检测失败，而是要求测试人员评估输出不一致。</p>
</blockquote>
<h4 id="1322-property-testing属性测试"><a class="header" href="#1322-property-testing属性测试">1.3.22. Property testing(属性测试)</a></h4>
<blockquote>
<p>Property testing is a testing technique where, instead of asserting that specific inputs produce specific expected outputs, the practitioner randomly generates many inputs, runs the program on all of them, and asserts the truth of some &quot;property&quot; that should be true for every pair of input and output. For example, every input to a sort function should have the same length as its output. Every output from a sort function should be a monotonically increasing list.
Property testing libraries allow the user to control the strategy by which random inputs are constructed, to ensure coverage of degenerate cases, or inputs featuring specific patterns that are needed to fully exercise aspects of the implementation under test.
Property testing is also sometimes known as &quot;generative testing&quot; or &quot;QuickCheck testing&quot; since it was introduced and popularized by the Haskell library &quot;<a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>.&quot;</p>
</blockquote>
<blockquote>
<p>基于属性的测试技术（ Property-based testing），是指编写对你的代码来说为真的逻辑语句（即“属性”），然后使用自动化工具来生成测试输入（一般来说，是指某种特定类型的随机生成输入数据），并观察程序接受该输入时属性是否保持不变。 如果某个输入违反了某一条属性，则用户证明程序存在一处错误，并找到一个能够演示该错误的便捷示例。 基于属性的测试技术的一个经典示例是测试一个sort（排序）函数，具体代码如下所示。 这个测试过程假定，给定一列整数，对其进行排序 - 保持元素的集合不变 - 生成一个有序输出 随后，测试框架将针对一些输入序列的集合自动化执行上述代码，并报告是否发现反例。</p>
</blockquote>
<h4 id="1323-vcr-testing记录重放测试播放测试"><a class="header" href="#1323-vcr-testing记录重放测试播放测试">1.3.23. VCR testing(记录重放测试/播放测试)</a></h4>
<blockquote>
<p>VCR testing, also known as &quot;playback testing&quot; or &quot;record/replay&quot; testing, is a testing technique for increasing the reliability and speed of regression tests that involve a component that is slow or unreliable to communicate with, often a third-party API outside of the tester's control. It involves making a recording (&quot;cassette&quot;) of the system's interactions with the external component, and then replaying the recorded interactions as a substitute for communicating with the external system on subsequent runs of the test.</p>
</blockquote>
<p>VCR测试，也称为“播放测试”或“记录/重放”测试，是提高回归测试的可靠性和速度的测试技术，涉及与之通信的组件，通常是第三方API的速度慢或不可靠 在测试人员的控制之外。 它涉及制作系统与外部组件的交互的录制（“盒式”），然后将记录的交互重播为与外部系统在后续运行中与外部系统进行通信的替代。</p>
<h4 id="1324-ad-hoc-testing随机测试"><a class="header" href="#1324-ad-hoc-testing随机测试">1.3.24. Ad-hoc Testing(随机测试)</a></h4>
<blockquote>
<p>随机测试主要是根据测试者的经验对软件进行功能和性能抽查。</p>
<p>根据测试说明书执行用例测试的重要补充手段，是保证测试覆盖完整性的有效方式和过程。</p>
<p>随机测试主要是对被测软件的一些重要功能进行复测，也包括测试那些当前的测试用例(TestCase)没有覆盖到的部分。</p>
</blockquote>
<h4 id="1325-exploratory-testing探索性测试"><a class="header" href="#1325-exploratory-testing探索性测试">1.3.25. Exploratory testing(探索性测试)</a></h4>
<blockquote>
<p>探索性测试可以说是一种测试思维技术。它没有很多实际的测试方法、技术和工具，但是却是所有测试人员都应该掌握的一种测试思维方式。探索性强调测试人员的主观能动性，抛弃繁杂的测试计划和测试用例设计过程，强调在碰到问题时及时改变测试策略。</p>
</blockquote>
<h2 id="2-软件测试分类边界划分"><a class="header" href="#2-软件测试分类边界划分">2. 软件测试分类边界划分</a></h2>
<h3 id="21-按开发阶段划分"><a class="header" href="#21-按开发阶段划分">2.1. 按开发阶段划分</a></h3>
<ul>
<li>单元测试(Unit Testing)</li>
<li>集成测试(Integration Testing)</li>
<li>系统测试(System Testing)</li>
<li>验收测试(Acceptance Testing)</li>
</ul>
<h3 id="22-按是否运行划分"><a class="header" href="#22-按是否运行划分">2.2. 按是否运行划分</a></h3>
<ul>
<li>静态测试(Static Testing)</li>
<li>动态测试(Dynamic Testing)</li>
</ul>
<h3 id="23-按是否查看代码划分"><a class="header" href="#23-按是否查看代码划分">2.3. 按是否查看代码划分</a></h3>
<ul>
<li>白盒测试(White-box Testing)</li>
<li>黑盒测试(Black-box Testing)</li>
<li>灰盒测试(Gray-box Testing)</li>
</ul>
<h3 id="24-按是否手工操作执行"><a class="header" href="#24-按是否手工操作执行">2.4. 按是否手工操作执行</a></h3>
<ul>
<li>Manual Testing(手工测试)
<blockquote>
<p>手工测试就是由人去一个一个的输入用例，然后观察结果，和机器测试相对应，属于比较原始但是必须的一个步骤。
优点：自动化无法替代探索性测试、发散思维类无既定结果的测试
缺点：执行效率慢，量大易错。</p>
</blockquote>
</li>
<li>Automation Testing(自动化测试)
<blockquote>
<p>就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。简单说自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。
自动化测试比如功能测试自动化、性能测试自动化、安全测试自动化。
通常所说的自动化是指功能测试自动化
AI技术的兴起发展，类似可预见工作都有可能会被伪AI代替.</p>
</blockquote>
</li>
</ul>
<h3 id="25-其他"><a class="header" href="#25-其他">2.5. 其他</a></h3>
<ul>
<li>随机测试(Ad-hoc Testing)</li>
<li>冒烟测试(Smoke Testing)</li>
<li>安全测试(Security Testing)</li>
<li>探索性测试(Exploratory Testing)</li>
<li>回归测试(Regression Testing)</li>
<li>α测试(Alpha Testing)</li>
<li>β测试(Beta Testing)</li>
<li>...</li>
</ul>
<h2 id="3-软件测试流程"><a class="header" href="#3-软件测试流程">3. 软件测试流程</a></h2>
<h3 id="31-传统的瀑布开发模式下的测试"><a class="header" href="#31-传统的瀑布开发模式下的测试">3.1. 传统的瀑布开发模式下的测试</a></h3>
<p>瀑布开发中的一个常见实践是测试是由一组独立的测试人员执行的。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Capability_Maturity_Model_Integration">能力成熟度模型集成</a></li>
<li><a href="https://en.wikipedia.org/wiki/Waterfall_model">瀑布开发模式</a></li>
</ul>
<h3 id="32-敏捷极限开发模式下的测试"><a class="header" href="#32-敏捷极限开发模式下的测试">3.2. 敏捷/极限开发模式下的测试</a></h3>
<p>相反，一些新兴的软件学科，如<a href="https://en.wikipedia.org/wiki/Extreme_programming">极限编程</a>和<a href="https://en.wikipedia.org/wiki/Agile_software_development">敏捷软件</a>开发运动，坚持“<a href="https://en.wikipedia.org/wiki/Test-driven_development">测试驱动的软件开发</a>”模型。</p>
<p>在这个过程中，软件工程师首先编写单元测试(通常使用极端编程方法中的结对编程)。预计测试最初会失败。每次失败的测试之后都编写足够的代码使其通过。</p>
<p>这意味着当发现新的故障条件和角落用例时，测试套件会不断更新，并且与开发的任何回归测试集成。单元测试与软件源代码的其余部分一起维护，通常集成到构建过程中(固有的交互性测试被归入部分手工的构建验收过程)。</p>
<p>这个测试过程的最终目标是支持<a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成</a>和减少缺陷率。</p>
<p>这种方法增加了开发完成的测试工作，在到达任何正式的测试团队之前。在其他一些开发模型中，大多数测试执行发生在定义了需求并完成了编码过程之后。</p>
<h3 id="33-测试的生命周期"><a class="header" href="#33-测试的生命周期">3.3. 测试的生命周期</a></h3>
<p>一般测试的生命周期，包括：</p>
<ul>
<li>需求分析：测试应在软件开发生命周期的需求阶段开始。 在设计阶段，测试人员可以确定设计的哪些方面是可测试的，并且需要哪些参数。</li>
<li>测试计划: 测试策略，测试计划，测试台创建。由于在测试期间将执行许多活动，因此需要一个计划。</li>
<li>测试开发: 测试过程，测试场景，测试用例，测试数据集，测试脚本。</li>
<li>测试执行: 测试人员根据计划和测试文档执行软件，然后报告开发团队中的任何错误。 在缺乏编程知识的运行测试时，此部分可能是复杂的。</li>
<li>输出测试报告: 一旦测试完成，测试人员生成量度，并对他们的测试工作以及被测试的软件是否准备好发布做出最终报告。</li>
<li>测试结果分析: 或者缺陷分析，通常是由开发团队和客户一起完成的，为了决定哪些缺陷应该被分配、修复、拒绝(即发现的软件正常工作)或者推迟到以后处理。</li>
<li>缺陷重新测试: 一旦开发团队处理了一个缺陷，测试团队就会重新测试它。</li>
<li>回归测试: 为了确保最新的交付没有破坏任何东西，并且软件产品作为一个整体仍然正确地工作，一个由测试子集构建的小测试程序是很常见的。</li>
<li>测试结束: 一旦测试符合退出标准，捕获关键输出，经验教训，结果，日志，与项目相关的文档等活动将被归档，并将其作为未来项目的参考。</li>
</ul>
<h2 id="4-软件测试组成部分"><a class="header" href="#4-软件测试组成部分">4. 软件测试组成部分</a></h2>
<h3 id="41-test-plan测试计划"><a class="header" href="#41-test-plan测试计划">4.1. Test plan(测试计划)</a></h3>
<blockquote>
<p>测试计划是一份详细说明将用于预期测试活动的方法的文档。计划可以包括目标、范围、过程和程序、人员要求和应急计划等方面测试计划可能是一个计划,包括所有形式的测试类型(如接受或系统测试计划)和规划考虑,或者它可能是发行主测试计划,概述了一个以上的详细测试计划(计划)的计划。在某些情况下，测试计划可以是广泛的“测试策略”的一部分，它记录了整个测试策略</p>
</blockquote>
<h3 id="42-traceability-matrix追溯矩阵"><a class="header" href="#42-traceability-matrix追溯矩阵">4.2. Traceability matrix(追溯矩阵)</a></h3>
<blockquote>
<p>追溯矩阵是将需求或设计文档与测试文档关联起来的表格。它用于在相关源文档被更改时更改测试，在计划回归测试时通过考虑需求覆盖率来选择测试用例以执行。</p>
</blockquote>
<h3 id="43-test-case测试用例"><a class="header" href="#43-test-case测试用例">4.3. Test case(测试用例)</a></h3>
<blockquote>
<p>测试用例通常由唯一的标识符组成，从设计规范，前提条件，事件，一系列步骤（也称为动作）来组成，以遵循，输入，输出，预期结果和实际结果。 临床定义，测试用例是输入和预期结果。这可以像“条件x的条件x一样”，尽管通常测试案例更详细地描述了输入方案以及可能预期的结果。 它偶尔可以是一系列步骤（但通常阶梯通常包含在单独的测试程序中，该测试程序可以根据经济问题而无法对多个测试用例进行），但具有一个预期的结果或预期结果。 可选字段是测试用例ID，测试步骤或执行编号，相关要求，深度，测试类别，作者以及复选框，以及是否自动化。 较大的测试用例也可能包含先决条件状态或步骤和描述。 测试案例还应包含实际结果的地方。 这些步骤可以存储在字处理器文档，电子表格，数据库或其他常见存储库中。 在数据库系统中，您还可以看到生成结果的过去的测试结果以及系统配置用于生成这些结果的测试结果。 这些过去的结果通常将存储在单独的表中。</p>
</blockquote>
<h3 id="44-test-script测试脚本"><a class="header" href="#44-test-script测试脚本">4.4. Test script(测试脚本)</a></h3>
<blockquote>
<p>测试脚本是复制用户操作的过程或编程代码。最初，这个术语来源于自动回归测试工具创建的工作产品。测试用例将是使用工具或程序创建测试脚本的基线。</p>
</blockquote>
<h3 id="45-test-suite测试套件"><a class="header" href="#45-test-suite测试套件">4.5. Test suite(测试套件)</a></h3>
<blockquote>
<p>测试用例的集合最常见的术语是测试套件。测试套件通常还包含每个测试用例集合的更详细的说明或目标。它肯定包含测试人员识别测试期间使用的系统配置的部分。一组测试用例也可能包含先决条件状态或步骤，以及对以下测试内容的描述。</p>
</blockquote>
<h3 id="46-test-fixture测试夹具data"><a class="header" href="#46-test-fixture测试夹具data">4.6. Test fixture(测试夹具)/data</a></h3>
<blockquote>
<p>在大多数情况下，使用多个值或数据集来测试特定特性的相同功能。所有的测试值和变化的环境成分收集在单独的文件中，并作为测试数据存储。为客户端和产品或项目提供这些数据也很有用。有一些技术可以生成测试数据。</p>
</blockquote>
<h3 id="47-test-harness测试工具"><a class="header" href="#47-test-harness测试工具">4.7. Test harness(测试工具)</a></h3>
<blockquote>
<p>软件、工具、数据输入和输出的样本，以及配置都被统称为测试工具。</p>
</blockquote>
<h3 id="48-test-run测试运行测试运行器"><a class="header" href="#48-test-run测试运行测试运行器">4.8. Test run(测试运行/测试运行器)</a></h3>
<blockquote>
<p>运行测试用例或测试套件的结果报告</p>
</blockquote>
<h2 id="5-软件测试质量度量"><a class="header" href="#5-软件测试质量度量">5. 软件测试质量度量</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Software_quality">https://en.wikipedia.org/wiki/Software_quality</a></p>
<blockquote>
<p>质量措施包括正确，完整性，安全性和ISO / IEC 9126要求等主题，例如能力，可靠性，效率，可移植性，可维护性，兼容性和可用性等要求。</p>
</blockquote>
<p>有许多常用的软件指标或措施，用于帮助确定软件的状态或测试的充分性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-软件架构模式"><a class="header" href="#1-软件架构模式">1. 软件架构模式</a></h1>
<h2 id="11-模式分类"><a class="header" href="#11-模式分类">1.1. 模式分类</a></h2>
<h3 id="111-分层模式layered-pattern"><a class="header" href="#111-分层模式layered-pattern">1.1.1. 分层模式（Layered pattern）</a></h3>
<h3 id="112-客户端-服务器模式client-server-pattern"><a class="header" href="#112-客户端-服务器模式client-server-pattern">1.1.2. 客户端-服务器模式（Client-server pattern）</a></h3>
<h3 id="113-主从模式master-slave-pattern"><a class="header" href="#113-主从模式master-slave-pattern">1.1.3. 主从模式（Master-slave pattern）</a></h3>
<h3 id="114-管道-过滤器模式pipe-filter-pattern"><a class="header" href="#114-管道-过滤器模式pipe-filter-pattern">1.1.4. 管道-过滤器模式（Pipe-filter pattern）</a></h3>
<h3 id="115-代理模式broker-pattern"><a class="header" href="#115-代理模式broker-pattern">1.1.5. 代理模式（Broker pattern）</a></h3>
<h3 id="116-点对点模式peer-to-peer-pattern"><a class="header" href="#116-点对点模式peer-to-peer-pattern">1.1.6. 点对点模式（Peer-to-peer pattern）</a></h3>
<h3 id="117-事件-总线模式event-bus-pattern"><a class="header" href="#117-事件-总线模式event-bus-pattern">1.1.7. 事件-总线模式（Event-bus pattern）</a></h3>
<h3 id="118-模型-视图-控制器模式model-view-controller-pattern"><a class="header" href="#118-模型-视图-控制器模式model-view-controller-pattern">1.1.8. 模型-视图-控制器模式（Model-view-controller pattern）</a></h3>
<h3 id="119-黑板模式blackboard-pattern"><a class="header" href="#119-黑板模式blackboard-pattern">1.1.9. 黑板模式（Blackboard pattern）</a></h3>
<h3 id="1110-解释器模式interpreter-pattern"><a class="header" href="#1110-解释器模式interpreter-pattern">1.1.10. 解释器模式（Interpreter pattern）</a></h3>
<h2 id="12-参考"><a class="header" href="#12-参考">1.2. 参考</a></h2>
<ul>
<li><a href="https://blog.csdn.net/wireless_com/article/details/89008061">《软件架构的10个常见模式》 1</a></li>
<li><a href="https://www.toutiao.com/i6706062415332639240/?tt_from=dingtalk&amp;utm_campaign=client_share&amp;timestamp=1626742528&amp;app=news_article&amp;utm_source=dingtalk&amp;utm_medium=toutiao_ios&amp;use_new_style=1&amp;req_id=202107200855280101351630941A2625B8&amp;share_token=0DCB74C6-6207-4A59-B845-04C3B2F496C9&amp;dtshare_count=1&amp;group_id=6706062415332639240">《软件架构的10个常见模式》 2 </a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务架构"><a class="header" href="#微服务架构">微服务架构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<h2 id="1-官方网站"><a class="header" href="#1-官方网站">1. 官方网站</a></h2>
<p><a href="https://kubernetes.io">https://kubernetes.io</a></p>
<h2 id="2-中文"><a class="header" href="#2-中文">2. 中文</a></h2>
<ul>
<li><a href="https://kubernetes.io/docs/home/">Kubernetes 官方文档中文版</a></li>
<li><a href="https://www.kubernetes.org.cn/">Kubernetes 中文社区</a></li>
<li><a href="https://kuboard.cn/">第三方 https://kuboard.cn/</a>
<ul>
<li>源码已经备份到 https://github.com/lauer3912/kuboard-press</li>
<li>在线Demo: <a href="https://demo.kuboard.cn/">https://demo.kuboard.cn/</a>, 用户名及密码: demo/demo123</li>
</ul>
</li>
</ul>
<h2 id="3-架构图及关键术语"><a class="header" href="#3-架构图及关键术语">3. 架构图及关键术语</a></h2>
<p>参见 <a href="https://kuboard.cn/learning/k8s-basics/k8s-core-concepts.html">复习Kubernetes核心概念</a></p>
<h2 id="4-安装"><a class="header" href="#4-安装">4. 安装</a></h2>
<h3 id="41-基于wsl2和kind或minikube搭建windows版kubernetes"><a class="header" href="#41-基于wsl2和kind或minikube搭建windows版kubernetes">4.1. 基于WSL2和Kind或Minikube：搭建Windows版Kubernetes</a></h3>
<p>参见：<a href="https://www.kubernetes.org.cn/7723.html">https://www.kubernetes.org.cn/7723.html</a></p>
<h2 id="5-常用术语"><a class="header" href="#5-常用术语">5. 常用术语</a></h2>
<ul>
<li><code>CRD</code>：CustomResourceDefinition, 在 Kubernetes 中一切都可视为资源，Kubernetes 1.7 之后增加了对 CRD 自定义资源二次开发能力来扩展 Kubernetes API，通过 CRD 我们可以向 Kubernetes API 中增加新资源类型，而不需要修改 Kubernetes 源码来创建自定义的 API server，该功能大大提高了 Kubernetes 的扩展能力。参考：<a href="https://www.jianshu.com/p/cc7eea6dd1fb">https://www.jianshu.com/p/cc7eea6dd1fb</a> 或 <a href="https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务网格中间件"><a class="header" href="#服务网格中间件">服务网格中间件</a></h1>
<p>引文参照：</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_39734304/article/details/103756132">服务网格——什么是服务网格(CSDN) 原理1</a></li>
<li><a href="https://blog.csdn.net/weixin_39734304/article/details/103756152">服务网格——什么是服务网格(CSDN) 原理2</a></li>
</ul>
<h2 id="更多文章"><a class="header" href="#更多文章">更多文章</a></h2>
<ul>
<li><a href="https://www.sofastack.tech/guides/kc-cloud-mesh-demo/">使用 CloudMesh 轻松实践 Service Mesh</a></li>
</ul>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p><a href="http://philcalcado.com/">Phil Calçado</a> 在他的这篇博客 <a href="http://philcalcado.com/2017/08/03/pattern_service_mesh.html">Pattern: Service Mesh</a> 中详细解释了服务网格的来龙去脉：</p>
<ol>
<li>从最原始的主机之间直接使用网线相连</li>
<li>网络层的出现</li>
<li>集成到应用程序内部的控制流</li>
<li>分解到应用程序外部的控制流</li>
<li>应用程序的中集成服务发现和断路器</li>
<li>出现了专门用于服务发现和断路器的软件包/库，如 Twitter 的 Finagle 和 Facebook 的 Proxygen，这时候还是集成在应用程序内部</li>
<li>出现了专门用于服务发现和断路器的开源软件，如 Netflix OSS、Airbnb 的 synapse 和 nerve</li>
<li>最后作为<strong>微服务的中间层服务网格</strong>出现</li>
</ol>
<h2 id="优缺点"><a class="header" href="#优缺点">优缺点</a></h2>
<p>参读《微服务架构深度解析：原理、实践与进阶》</p>
<h2 id="蚂蚁金服"><a class="header" href="#蚂蚁金服">蚂蚁金服</a></h2>
<p>在线预览 <a href="micro-services/service-mesh/./asserts/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D-%E4%BD%BF%E7%94%A8CloundMesh%E4%BD%93%E9%AA%8CServiceMesh.pdf">蚂蚁金服-使用CloundMesh体验ServiceMesh.pdf</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knative"><a class="header" href="#knative">Knative</a></h1>
<h2 id="定位"><a class="header" href="#定位">定位</a></h2>
<p><img src="micro-services/knative/./assets/knative-pos.jpg" alt="" /></p>
<h2 id="引用"><a class="header" href="#引用">引用</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/172431080">Knative：新一代Serverless平台</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sealos-蜜罐"><a class="header" href="#sealos-蜜罐">Sealos 蜜罐</a></h1>
<p>阿里巴巴从去年五月份内部开始在某些场景使用sealos，内部fork的版本trident在sealos基础上作出了非常多的优化使系统更加稳定功能更加强大。 21年开始重大创新的想法也彻底使sealos脱胎换骨，实现整个集群的 build share run, 我们希望这些能力也能够惠及更多开源社区的开发者们。</p>
<h2 id="站点链接"><a class="header" href="#站点链接">站点链接</a></h2>
<ul>
<li><a href="https://github.com/fanux/sealos">https://github.com/fanux/sealos</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="云原生架构"><a class="header" href="#云原生架构">云原生架构</a></h1>
<h2 id="特性"><a class="header" href="#特性">特性</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="案例"><a class="header" href="#案例">案例</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zadig-业务架构"><a class="header" href="#zadig-业务架构">Zadig 业务架构</a></h1>
<p>云原生持续交付
面向开发者设计的开源、高可用 CI/CD：Zadig 强大的云原生多环境能力，轻松实现本地联调、微服务并行构建、集成测试和持续部署。 Zadig 不改变现有流程，无缝集成 GitHub/GitLab、Jenkins、多家云厂商。</p>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p><a href="https://koderover.com">https://koderover.com/</a></p>
<p>Zadig 是 KodeRover 公司基于 Kubernetes 自主设计、研发的开源分布式持续交付 (Continuous Delivery) 产品，为开发者提供云原生运行环境，支持开发者本地联调、微服务并行构建和部署、集成测试等。Zadig 内置了面向 Kubernetes、Helm、云主机、大体量微服务等复杂业务场景的最佳实践，为工程师一键生成自动化工作流 (workflow)。Zadig 不改变现有习惯和流程，几乎兼容所有软件架构，无缝集成 GitHub/GitLab、Jenkins、多家云厂商等，运维成本极低。</p>
<h2 id="架构图"><a class="header" href="#架构图">架构图</a></h2>
<p><img src="cloud-native/case/./assets/Zadig-Business-Architecture-zh.jpg" alt="" /></p>
<h2 id="核心能力"><a class="header" href="#核心能力">核心能力</a></h2>
<ul>
<li>
<p>高并发的工作流</p>
<blockquote>
<p>系统经过简单配置，即可自动生成高并发工作流，高效执行构建、部署、测试等任务。这一设计解决了微服务架构下带来的多服务交付效率低下的问题。</p>
</blockquote>
</li>
<li>
<p>以服务为核心的集成环境</p>
<blockquote>
<p>只需一套服务配置，即可在几分钟创建多套数据隔离的测试环境，为开发者日常调试、集成测试验证、产品演示提供强力支撑。现有环境无需迁移，一键托管即可轻松浏览、调试环境中的所有服务。</p>
</blockquote>
</li>
<li>
<p>无侵入的自动化测试</p>
<blockquote>
<p>便捷对接已有的自动化测试框架，通过 GitHub/GitLab WebHook 自动构建、部署、测试。通过办公 IM 机器人为开发者提供第一时间质量反馈，有效实现“测试左移”，充分体现测试价值。</p>
</blockquote>
</li>
<li>
<p>开发本地联调 CLI</p>
<blockquote>
<p>开发可以本地编辑代码，一键构建、部署到联调环境，无需处理复杂且繁琐的工作流程，省出宝贵时间去创造更多产品价值。</p>
</blockquote>
</li>
</ul>
<h2 id="为谁服务"><a class="header" href="#为谁服务">为谁服务</a></h2>
<h3 id="开发工程师"><a class="header" href="#开发工程师">开发工程师</a></h3>
<ul>
<li>基于 Git PR 级别的持续集成，并获得单元测试，代码扫描，耗时和通过率的质量反馈和改进建议</li>
<li>定时器/WebHook 支持 PR/Branch 自动触发执行交付工作流，集成环境更新，自动化测试，获得详细的质量结果反馈</li>
<li>一键生成独立集成环境，可直连容器云集成环境进行开发、调试、自测</li>
</ul>
<h3 id="测试开发工程师"><a class="header" href="#测试开发工程师">测试（开发）工程师</a></h3>
<ul>
<li>测试任务维护和管理，通过工作流执行自动化功能测试和性能，获得相应测试报告</li>
<li>管理/执行一个项目的交付工作流任务，成功执行后，进行版本交付，并获得交付版本的服务配置、镜像信息、代码信息、测试结果等</li>
</ul>
<h3 id="devops-工程师"><a class="header" href="#devops-工程师">DevOps 工程师</a></h3>
<ul>
<li>一个产品可以实现完整的容器化集成环境管理</li>
<li>根据 Branch/Tag 执行发布工作流，版本交付完整信息数据流，不限于需求/代码/工作流/配置的 changelog</li>
</ul>
<h3 id="项目管理产品管理工程效率管理人员"><a class="header" href="#项目管理产品管理工程效率管理人员">项目管理/产品管理/工程效率管理人员</a></h3>
<ul>
<li>可以随时将新功能展示给内外部用户 POC</li>
<li>实现对不同客户进行内部交付版本管理和检索</li>
<li>可查看各团队持续集成、持续交付、持续部署等行业效能 DevOps 指标</li>
</ul>
<h2 id="功能介绍"><a class="header" href="#功能介绍">功能介绍</a></h2>
<ul>
<li>
<p>开源版：具有产品持续交付、持续测试、持续追踪的全流程能力，包括以下核心功能：</p>
<ul>
<li>项目管理：服务管理、构建管理、环境管理、共享服务、环境授权</li>
<li>工作流交付：产品工作流并发队列</li>
<li>质量管理：持续集成度量、自动化测试、性能测试管理</li>
<li>交付中心：交付物和制品追踪 (代码、构建、工作流、测试、操作人等信息)、产品级版本管理</li>
<li>质效中心：质效看板-持续集成、持续交付、持续部署</li>
<li>集成管理：GitHub/GitLab/Gerrit 集成、内部账号管理、SSO/LDAP/AD账号、Jira 集成、邮件集成</li>
<li>基础组件：Registry 管理、应用与构建依赖管理、对象存储、集群管理、云主机管理</li>
<li>支持 Python，Java，Go，C，C++，.Net Linux 版等几乎所有编程语言。</li>
</ul>
</li>
<li>
<p>企业版：除产品核心功能版所描述功能外，还支持企业级功能：</p>
<ul>
<li>质效中心：DevOps 洞察 - 构建、测试、持续交付洞察</li>
<li>企业管理：RBAC 权限、操作日志审计</li>
<li>专属技术支持群</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codespaces-github-在线开发环境"><a class="header" href="#codespaces-github-在线开发环境">Codespaces GitHub 在线开发环境</a></h1>
<h2 id="1-简介"><a class="header" href="#1-简介">1. 简介</a></h2>
<p>2021-08 GitHub 官方宣布，负责 github.com 的工程团队已将开发环境迁移至 <a href="https://github.com/features/codespaces">Codespaces</a>。</p>
<p>引用新闻:</p>
<ul>
<li><a href="https://www.oschina.net/news/154976/githubs-engineering-team-moved-codespaces">GitHub 工程团队的开发环境迁移至 Codespaces</a></li>
</ul>
<h2 id="2-网站"><a class="header" href="#2-网站">2. 网站</a></h2>
<ul>
<li><a href="https://github.com/features/codespaces">https://github.com/features/codespaces</a></li>
<li><a href="https://docs.github.com/cn/codespaces/about-codespaces">关于 codespaces</a></li>
<li><a href="https://docs.github.com/cn/codespaces/codespaces-reference/about-billing-for-codespaces">计费标准</a></li>
</ul>
<h2 id="3-特性"><a class="header" href="#3-特性">3. 特性</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件设计模式"><a class="header" href="#软件设计模式">软件设计模式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="故障设计"><a class="header" href="#故障设计">故障设计</a></h1>
<h2 id="1-简介-1"><a class="header" href="#1-简介-1">1. 简介</a></h2>
<p>通常情况下，我们的一个请求会经过三个服务来处理。</p>
<p><img src="design-for-software/./assets/design-for-failure-01.png" alt="" /></p>
<p>请求从客户端发出，到达Proxy Layer（执行一些公共的逻辑，如逻辑、流控、审计等），完成后，发往App Layer（执行具体业务逻辑），执行完毕后，发向Data Laye（进行数据持久化）。</p>
<p>事情看起来很简单，然而，在一个分布式系统中：<code>出错是常态</code>。
因此，我们需要：<code>Design For Failure</code>。即当你的系统将错误当作正常流时，系统便已经对错误免疫了。
在此，跟大家介绍常见的12种设计思想。</p>
<h2 id="2-设计思想"><a class="header" href="#2-设计思想">2. 设计思想</a></h2>
<h3 id="21-防御性设计defensive-design"><a class="header" href="#21-防御性设计defensive-design">2.1. 防御性设计(Defensive Design)</a></h3>
<p>所谓的防御性设计实际上就是“防呆”，英文叫Idiot Proofing。说白了就是用户有时候会不自觉的做一些蠢事，我们在设计的时候要尽量考虑到一些不规范的交互行为，如果你的用户是一只猴子，你要写包单保证系统不被玩坏。</p>
<blockquote>
<p>注：防御性设计是一种设计思想，它的目的是为了防止用户在系统中做出错误的行为。
例如，在Android开发中使用到的Monkey Test就是用于这样的目的。</p>
</blockquote>
<h3 id="22-边界情况edge-case"><a class="header" href="#22-边界情况edge-case">2.2. 边界情况(Edge Case)</a></h3>
<p>这个设计思想在测试领域比较常见，就是我们在设计我们的设计案例的时候有没有充分考虑在边界情况下的系统行为。</p>
<blockquote>
<p>例如：在设计一个系统的时候，我们需要考虑到系统的边界情况，比如：系统的边界情况是用户输入的数据是否合法，或者是系统的边界情况是用户输入的数据是否合法。
比较常见的例如，闰年情况、跨日情况等边界。</p>
</blockquote>
<h3 id="23-防误措施mistake-proofing"><a class="header" href="#23-防误措施mistake-proofing">2.3. 防误措施(Mistake Proofing)</a></h3>
<p>怎么保证不会发生错误。例如在人机交互环节，能不能进行输入校验？</p>
<h3 id="24-解耦decoupling"><a class="header" href="#24-解耦decoupling">2.4. 解耦(Decoupling)</a></h3>
<p>设计的时候，哪怕是最基础的代码也应该符合开闭原则。
Spring的<code>IOC</code>就是为了把对象创建及维护从原来的由引用类负责这种强耦合模式转成通过spring容器负责。且解耦一般的做法是通过把内部逻辑封装起来，暴露对外统一API接口，调用方不需要了解被调用方的内部逻辑实现，只需要知道提供什么功能即可。</p>
<blockquote>
<p>再引申一下，解耦的作用就在于复用，把所有的高内聚功能独立成一个个模块，然后就可以像乐高积木一样根据调用方的实际需求进行组装。</p>
</blockquote>
<h3 id="25-冗余redundancy"><a class="header" href="#25-冗余redundancy">2.5. 冗余(Redundancy)</a></h3>
<p>所谓的冗余指的通过重复配置关键组件或部件，保证在关键组件失效的情况下还有备份组件运作以便保证系统可以继续提供服务。生活中的例子请参与飞机的双引擎设计。
主从模式就是冗余的体现。在正常情况下，主实例负责提供全部的服务，从实例在主实例整体或部分不可用的情况下，完全替代主实例整体或局部而对外提供服务。</p>
<h3 id="26-重试retry"><a class="header" href="#26-重试retry">2.6. 重试(Retry)</a></h3>
<p>重试是在分布式系统下处理瞬态故障的一个基本手段，简单有效（当然重试的前提是要求幂等）。但是重试也是可以很危险的，它能够引起把一个局部小时间迅速升级为一个系统重大故障，严重者导致系统假死。</p>
<p><img src="design-for-software/./assets/design-for-failure-02.png" alt="" /></p>
<h3 id="27-冷备cold-standby"><a class="header" href="#27-冷备cold-standby">2.7. 冷备(Cold Standby)</a></h3>
<p>冷备实际上也是冗余设计的其中一种体现，只是它会更侧重于“冷”，意思是当系统发生宕机时，这个系统是需要手动启动用于替换下线的主实例，它是跟热备是不一样，热备更多体现在自动切换。</p>
<h3 id="28-熔断derating"><a class="header" href="#28-熔断derating">2.8. 熔断(Derating)</a></h3>
<p>熔断本质上就是一种防御性设计或者策略。假设一个微服务体系下的系统，其中A服务调用B服务。系统的QPS是千级别，当时如果B服务挂掉的话A的线程绝对在短时间内占满耗尽而导致假死，从而形成大量A请求积压而导致情况恶化，最终形成雪崩。</p>
<h3 id="29-容错error-tolerance"><a class="header" href="#29-容错error-tolerance">2.9. 容错(Error Tolerance)</a></h3>
<p>狭义的容错泛指人机交互界面的时候需要对用户输入进行输入校验，保证数据准确性。
广义的容错应该是两个具有明确边界的事物（如服务间，系统间）交互时候针对可能发生的一切主客观异常情况的防御性手段。常见的容错机制有failsafe、failback、failover、failfast。</p>
<ul>
<li>failfast 更多指的是快速失败，避免线程积压导致系统滚雪球式崩溃。</li>
<li>failover 指的是失效转移。</li>
<li>failsafe 指的是失效安全。</li>
<li>failback 指的是失效自动恢复，将故障实例切换到备实例。</li>
</ul>
<h3 id="210-失效安全fail-safe"><a class="header" href="#210-失效安全fail-safe">2.10. 失效安全(Fail safe)</a></h3>
<p>所谓的失效安全，就是指在特定失效的情况下，一个系统或者服务也不会对业务造成损害。</p>
<blockquote>
<p>例如：我们使用token进行安全登录也是一种失效安全的体现，如果token失效了（如时间过期），用户是无法登录的，因为正常登录需要token有一种约束因素，这种因素就是时间。如果时间过了，代表这种约束因素不存在或者不再有效了，登录功能就不能正常工作了。</p>
</blockquote>
<h3 id="211-优雅降级graceful-degradation"><a class="header" href="#211-优雅降级graceful-degradation">2.11. 优雅降级(Graceful Degradation)</a></h3>
<p>服务降级跟熔断还是挺像的，只是降级来得更加温和和优雅一点。熔断是直接断掉防止异常进一步扩大而导致雪崩，但是我们的终极目标是提供尽可能多的服务，这个就是优雅降级的理念。在一些异常情况或者秒杀场景下，为了保证核心服务（如商品下单、支付）的正常可用，会放弃掉一些非核心服务（如历史账单查询），这就是所谓的服务降级。</p>
<blockquote>
<p>在微服务框架中，一般会使用Hystrix的@HystrixCommand或Feign的@FeignClient对服务进行声明，然后为每个服务配置相应的fallback类，最终结合起来进行服务降级。</p>
</blockquote>
<h3 id="212-耐用性durability"><a class="header" href="#212-耐用性durability">2.12. 耐用性(Durability)</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件工程开发流程"><a class="header" href="#软件工程开发流程">软件工程开发流程</a></h1>
<h2 id="借鉴"><a class="header" href="#借鉴">借鉴</a></h2>
<ul>
<li><a href="https://www.spaceotechnologies.com/software-development-process/">https://www.spaceotechnologies.com/software-development-process/</a></li>
</ul>
<h2 id="开发模式"><a class="header" href="#开发模式">开发模式</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件发布策略"><a class="header" href="#软件发布策略">软件发布策略</a></h1>
<h2 id="1-引言"><a class="header" href="#1-引言">1. 引言</a></h2>
<p>借鉴阿里巴巴集团的研发说法：</p>
<p>阿里巴巴集团内部有不少故障是因为发布直接或间接引起。因此提升发布的质量，减少错误的发生，是有效减少线上故障的一个关键环节。</p>
<p><strong>为什么大部分的故障和发布相关？</strong></p>
<ul>
<li>因为发布是整个功能更新到线上的最后一个环节，一些研发过程中累计的问题，在最后发布环节才会触发。同</li>
<li>时发布本身也是一个复杂的过程，在发布过程中，往往容易出现一些错误操作或者遗漏关键操作。</li>
</ul>
<h2 id="2-发布策略种类"><a class="header" href="#2-发布策略种类">2. 发布策略种类</a></h2>
<h3 id="21-灰度发布策略"><a class="header" href="#21-灰度发布策略">2.1. 灰度发布策略</a></h3>
<p>灰度发布是发布整个过程中一个非常重要的环境。目前灰度发布策略有这几种:</p>
<h4 id="211-蓝绿发布blue-green-deployment"><a class="header" href="#211-蓝绿发布blue-green-deployment">2.1.1. 蓝绿发布(Blue-Green Deployment)</a></h4>
<p>通过部署两套环境来解决新老版本的发布问题。如果新版本(New Version)发生问题要进行回滚的时候，直接通过切流将流量全部切到老版本(Old Version)上。</p>
<p>优点：升级切换和回退比发布回滚迅速
缺点：成本较高，需要部署两套环境。如果新版本中基础服务出现问题，会瞬间影响全网用户；如果新版本有问题也会影响全网用户</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="灰度发布"><a class="header" href="#灰度发布">灰度发布</a></h1>
<p>借鉴阿里巴巴集团的研发说法：</p>
<p>阿里巴巴集团内部有不少故障是因为发布直接或间接引起。因此提升发布的质量，减少错误的发生，是有效减少线上故障的一个关键环节。</p>
<p><strong>为什么大部分的故障和发布相关？</strong></p>
<ul>
<li>因为发布是整个功能更新到线上的最后一个环节，一些研发过程中累计的问题，在最后发布环节才会触发。同</li>
<li>时发布本身也是一个复杂的过程，在发布过程中，往往容易出现一些错误操作或者遗漏关键操作。</li>
</ul>
<p>灰度发布是发布整个过程中一个非常重要的环境。目前灰度发布策略有这几种:</p>
<h2 id="1-蓝绿发布blue-green-deployment"><a class="header" href="#1-蓝绿发布blue-green-deployment">1. 蓝绿发布(Blue-Green Deployment)</a></h2>
<p>通过部署两套环境来解决新老版本的发布问题。如果新版本(New Version)发生问题要进行回滚的时候，直接通过切流将流量全部切到老版本(Old Version)上。</p>
<p><img src="release-strategy/./assets/blue-green-deployment.png" alt="蓝绿发布(Blue-Green Deployment)" /></p>
<ul>
<li>优点：
<ul>
<li>升级切换和回退比发布回滚迅速</li>
</ul>
</li>
<li>缺点：
<ul>
<li>成本较高，需要部署两套环境。</li>
<li>如果新版本中基础服务出现问题，会瞬间影响全网用户；</li>
<li>如果新版本有问题也会影响全网用户.</li>
</ul>
</li>
</ul>
<h2 id="2-金丝雀发布canary-release"><a class="header" href="#2-金丝雀发布canary-release">2. 金丝雀发布(Canary Release)</a></h2>
<p><img src="release-strategy/./assets/canary-release.png" alt="金丝雀发布(Canary Release)" /></p>
<ul>
<li>优点：
<ul>
<li>灵活，策略自定义，可以按照流量或具体的内容进行灰度(比如不同账号，不同参数)，出现问题不会影响全网用户</li>
</ul>
</li>
<li>缺点：
<ul>
<li>没有覆盖到所有的用户导致出现问题不好排查.</li>
</ul>
</li>
</ul>
<h2 id="3-滚动发布rolling-release"><a class="header" href="#3-滚动发布rolling-release">3. 滚动发布(Rolling Release)</a></h2>
<p><img src="release-strategy/assets/rolling-release.png" alt="滚动发布(Rolling Release)" /></p>
<p>金丝雀发布的一种变化。通过分批发布的方式进行多批发布(比如一共 9 个实例，分 3 批，每次 3 个实例发布)，适合大规模应用发布</p>
<ul>
<li>优点：
<ul>
<li>出现问题不会影响全网用户，适合大规模应用发布</li>
</ul>
</li>
<li>缺点：
<ul>
<li>发布和回滚周期较长</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参照软件模式"><a class="header" href="#参照软件模式">参照软件模式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api重新构想"><a class="header" href="#api重新构想">API重新构想</a></h1>
<p>很多架构师认为，API是原生语言。具有代表意义的 <a href="https://autocode.com/">Autocode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="autocode的standard-library"><a class="header" href="#autocode的standard-library">autocode的Standard Library</a></h1>
<ul>
<li><a href="https://github.com/acode">https://github.com/acode</a></li>
<li><a href="https://autocode.com">https://autocode.com</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网站分析"><a class="header" href="#网站分析">网站分析</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="github"><a class="header" href="#github">GitHub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="爱奇艺"><a class="header" href="#爱奇艺">爱奇艺</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai助力"><a class="header" href="#ai助力">AI助力</a></h1>
<h2 id="ai-库"><a class="header" href="#ai-库">AI 库</a></h2>
<ul>
<li><a href="https://www.tensorflow.org/">谷歌 TensorFlow</a>
<ul>
<li><a href="https://blog.tensorflow.org/search?label=TensorFlow.js&amp;max-results=20">TensorFlow.js 资源</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优秀项目资源"><a class="header" href="#优秀项目资源">优秀项目资源</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="低代码无代码"><a class="header" href="#低代码无代码">低代码/无代码</a></h1>
<p>10年前，互联网上的大多数网站和应用程序设计用于依赖开发人员，大家都必须在白天和晚上工作，以使其代码工作。</p>
<p>引文:</p>
<ul>
<li><a href="https://pinver.medium.com/decoding-the-no-code-low-code-startup-universe-and-its-players-4b5e0221d58b">https://pinver.medium.com/decoding-the-no-code-low-code-startup-universe-and-its-players-4b5e0221d58b</a></li>
<li><a href="https://www.toutiao.com/i6991709936115794464/?tt_from=dingtalk&amp;utm_campaign=client_share&amp;timestamp=1628139654&amp;app=news_article&amp;utm_source=dingtalk&amp;utm_medium=toutiao_ios&amp;use_new_style=1&amp;req_id=202108051300540101351641010905CFE6&amp;share_token=293D09F7-CD57-42A7-9FC3-7FA64ECB8F20&amp;dtshare_count=1&amp;group_id=6991709936115794464">解码无代码/低代码创业公司及其玩家</a></li>
</ul>
<p>迄今，任何有计算机和访问互联网的人都可以使用极其强大的应用构建网站，应用程序或内部工具：<strong>没有代码和低代码工具</strong>。</p>
<p>它不会停在网站和应用程序中：今天没有深度技术技能的人可以在线运行他们的整个公司，设置电子商务业务，甚至发行银行！</p>
<p>例如，<code>Nuage Stays</code> - 最近在年度重复收入达到500万美元 - 是使用低码工具建造的，例如Airtable，Zapier等，用于管理预订，收集和存储数据，创建日历等。</p>
<p>这个新的技术时代没有被忽视：多个人写了关于此前越来越多的趋势，越来越多的人似乎正在追捕：</p>
<p><strong>无代码/低代码的意思是什么？</strong></p>
<p>它是一种方法和程序的移动，不一定涉及写入代码，而是与图形用户界面（GUI）一起工作，其中人们可以使用模板，拖放功能，会话接口和逻辑序列来带来任何数字产品现实。</p>
<p>这种新兴类别是关于软件开发的民主化，解锁了数字化为可以访问计算机或电话互联网的任何人带来的潜力。</p>
<p><strong>让我们清楚</strong>：</p>
<ul>
<li>无代码和低码工具不是消除代码或工程师。</li>
<li>他们是关于让人们更轻松地让人的生活，同时对每个人开放，让每个人都成为“<strong>公民开发人员</strong>”。</li>
<li>他们是抽象脱离代码的复杂性，专注于设计和逻辑。这意味着不再需要做无聊，平凡和非项目任务。</li>
</ul>
<p>通过这些工具，世界上任何地方的销售/营销/产品/运营团队和创始人可以在<strong>不需要任何技术知识的情况下</strong>建立复杂的工作流程和应用程序。</p>
<p><strong>投资世界似乎也注意到了这一趋势</strong>：</p>
<p>仅在上个月，非常大的资金回合在空间中宣布：Zapier的第二轮投资，估值为50亿美元，Outsystems为9.5亿美元的估值融资150M，Creatio首次融资68M，Rows B轮融资$ 16m，Oribi B轮融资的1550万美元等……势头如此强大，有些人认为它是一种热潮，与我们看到的聊天机器人，数字化货币，和大麻相关的热度相当。</p>
<p>使用生态系统中的数百个工具以及使用它们的建筑商和制造商合作，我们通常会看到此类别分段为：</p>
<ul>
<li><strong>无代码</strong>：
<ul>
<li>这包括工具与字面为零的代码，为不知道编程代码技术的人制作，永远不想知道软件如何运作。</li>
<li>他们只是希望它工作，看起来不错。 （例如Universe，Gumroad等）。</li>
<li>这些工具不能通过设计更加复杂。这个空间的公司感到魔术。</li>
<li>您可以在15分钟内在手机上建立网站，或以灵活的动态方式在产品中为您的产品带来条纹计费。</li>
<li>它们通常使用易用，客户获得了很多支持，大多数公司都有充满活力的非技术人员互相帮助的社区。</li>
<li>还包括工具和软件，用于良好的系统思想家，并在应用程序编程接口（API）周围知道他们的方式（例如，AirTable，Zapier，Webflow等）。</li>
<li>这些工具确实有能力被配置为更复杂，包括代码元素如果想要更深入。</li>
<li>这一细分市场不仅拥有1000万美元的估值标志，这是一个超过1000万美元的公司，它正在成为生态系统的繁殖基础。</li>
<li>思考亚特萨斯人作为整个生态系统所做的事情，然后将其应用于WebFlow或AirTable生态系统。</li>
</ul>
</li>
<li><strong>低代码</strong>：
<ul>
<li>想要查找更快，更容易，更便宜的制造和规模的工具和工程师的工具和软件，而不会放弃代码带来的定制。（例如8Base，Retool，Internal等）。</li>
<li>该部分的公司仍然需要一定程度的技术专业知识，但通常允许用户提高其生产力并节省大量的任务时间。</li>
</ul>
</li>
</ul>
<h2 id="1-website-builders--enhancers网站建造者和提升者"><a class="header" href="#1-website-builders--enhancers网站建造者和提升者">1. Website Builders &amp; Enhancers(网站建造者和提升者)</a></h2>
<h2 id="2-app-builders-mobile-first应用建造者移动优先"><a class="header" href="#2-app-builders-mobile-first应用建造者移动优先">2. App Builders, Mobile-first(应用建造者，移动优先)</a></h2>
<h2 id="3-app-builders--enhancers-web-first应用建造者和提升者网页优先"><a class="header" href="#3-app-builders--enhancers-web-first应用建造者和提升者网页优先">3. App Builders &amp; Enhancers, Web-first(应用建造者和提升者，网页优先)</a></h2>
<h2 id="4-internal-tools--internal-app-builders内部工具和内部应用建造者"><a class="header" href="#4-internal-tools--internal-app-builders内部工具和内部应用建造者">4. Internal Tools &amp; Internal App Builders(内部工具和内部应用建造者)</a></h2>
<h2 id="5-workflow-automation-tools工作流自动化工具"><a class="header" href="#5-workflow-automation-tools工作流自动化工具">5. Workflow Automation Tools(工作流自动化工具)</a></h2>
<h2 id="6-data--developer-productivity数据和开发者生产力"><a class="header" href="#6-data--developer-productivity数据和开发者生产力">6. Data &amp; Developer Productivity(数据和开发者生产力)</a></h2>
<h2 id="7-spreadsheets-on-steroids电子表格和超级记事本"><a class="header" href="#7-spreadsheets-on-steroids电子表格和超级记事本">7. Spreadsheets on Steroids(电子表格和超级记事本)</a></h2>
<h2 id="8-numbers-finance--modelling数字财务和模型"><a class="header" href="#8-numbers-finance--modelling数字财务和模型">8. Numbers, Finance &amp; Modelling(数字，财务和模型)</a></h2>
<h2 id="9-payments--transactions支付和交易"><a class="header" href="#9-payments--transactions支付和交易">9. Payments &amp; Transactions(支付和交易)</a></h2>
<h2 id="10-checkouts-subscriptions-memberships--commerce结算订阅会员商业"><a class="header" href="#10-checkouts-subscriptions-memberships--commerce结算订阅会员商业">10. Checkouts, Subscriptions, Memberships &amp; Commerce(结算，订阅，会员，商业)</a></h2>
<h2 id="11-low-code-analytics--dashboards低代码分析和仪表板"><a class="header" href="#11-low-code-analytics--dashboards低代码分析和仪表板">11. Low-code Analytics &amp; Dashboards(低代码分析和仪表板)</a></h2>
<h2 id="12-form-builders表单建造者"><a class="header" href="#12-form-builders表单建造者">12. Form Builders(表单建造者)</a></h2>
<h2 id="13-典型网站"><a class="header" href="#13-典型网站">13. 典型网站</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见比较"><a class="header" href="#常见比较">常见比较</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务代理软件"><a class="header" href="#服务代理软件">服务代理软件</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="比较nginx与apache-apisx"><a class="header" href="#比较nginx与apache-apisx">比较Nginx与Apache APISX</a></h1>
<h2 id="附录"><a class="header" href="#附录">附录</a></h2>
<ul>
<li><a href="https://www.toutiao.com/i6992798379403117069/?tt_from=dingtalk&amp;utm_campaign=client_share&amp;timestamp=1628170857&amp;app=news_article&amp;utm_source=dingtalk&amp;utm_medium=toutiao_ios&amp;use_new_style=1&amp;req_id=202108052140560101351680875608044A&amp;share_token=9FA435CD-9602-49E7-9B3D-036504E496E8&amp;dtshare_count=1&amp;group_id=6992798379403117069">如何利用 Apache APISX 提升 Nginx 的可观测性</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络协议"><a class="header" href="#网络协议">网络协议</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="比较-grpc-服务和-http-api"><a class="header" href="#比较-grpc-服务和-http-api">比较 gRPC 服务和 HTTP API</a></h1>
<h2 id="引文-1"><a class="header" href="#引文-1">引文</a></h2>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/comparison?view=aspnetcore-5.0">微软文档关于《gRPC 服务和 HTTP API》的差异</a></li>
<li><a href="https://opensource.google/projects/grpc">Google开源的gRPC站点</a></li>
<li><a href="https://www.grpc.io/">gRPC 编程</a></li>
</ul>
<h2 id="grpc"><a class="header" href="#grpc">gRPC</a></h2>
<p><code>gRPC</code>是谷歌开源的一个 RPC 框架，面向移动和 <code>HTTP/2</code> 设计。</p>
<ul>
<li>内容交换格式采用<code>ProtoBuf(Google Protocol Buffers)</code>，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。</li>
<li>传输协议 采用<code>http2</code>，性能比<code>http1.1</code>好了很多</li>
<li>和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。</li>
</ul>
<p><code>ProtoBuf</code> 具有强大的<code>IDL</code>（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。</p>
<h2 id="http2"><a class="header" href="#http2">HTTP/2</a></h2>
<ul>
<li>新的二进制格式:
<blockquote>
<p>HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。</p>
</blockquote>
</li>
<li>多路复用
<blockquote>
<p>多个request共享一个连接。</p>
</blockquote>
</li>
<li>header压缩
<blockquote>
<p>在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。</p>
</blockquote>
</li>
<li>服务端推送
<blockquote>
<p>主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。</p>
</blockquote>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
